---
tags:
title: 鉴权与加密算法
date created: 2023-04-04
date modified: 2023-04-26
---

# 鉴权与加密算法

## 加密算法

### [[base64]] 加密

### [[内容摘要加密算法]]（MD5、SHA1、SHA256、SHA512）

### 内容加密解密类又分为： 对称加密解密（AES），非对称加密解密(RSA)

可逆！

#### 对称加密算法 AES

```JavaScript
//AES对称加密
var secretkey = "passwd";//唯一（公共）秘钥
var content = "需要加密的内容ABC";
var cipher = crypto.createCipher('aes192', secretkey);//使用aes192加密
var enc = cipher.update(content, "utf8", "hex");//编码方式从utf-8转为hex;
enc += cipher.final('hex');//编码方式转为hex;
//
//AES对称解密
var decipher = crypto.createDecipher('aes192', secretkey);
var dec = decipher.update(enc, "hex", "utf8");
dec += decipher.final("utf8");
console.log("AES对称解密结果：" + dec);
```

#### **RSA 非对称加密**

先使用 openSSl 生成 `公钥` 和 `私钥`

```cmd
openssl genrsa -out privatekey.pem 1024
openssl rsa -in privatekey.pem -pubout -out publickey.pem
```

公钥一般用来进行加密，而私钥一般用来进行解密，当然你也可以颠倒过来使用，私钥加密公钥解密都是可以的（只是一般不这么使用）。

```JavaScript
const fs = require("fs");

const privatepem2 = fs.readFileSync("./privatekey.pem");//私有key【需要 pem 编码的key】server.pem
const publicpem2 = fs.readFileSync("./publickey.pem");//公有key【需要 pem 编码的key】cert.pem
const prikey2 = privatepem2.toString();
const pubkey2 = publicpem2.toString();
// 加密方法
var encrypt = (data, key) => {
    // 注意，第二个参数是Buffer类型
    return crypto.publicEncrypt(key, Buffer.from(data));
};
// 解密方法
var decrypt = (encrypted, key) => {
    // 注意，encrypted是Buffer类型
    return crypto.privateDecrypt(key, encrypted);
};

const plainText = "我是RSA非对称加密字符串内容";
const crypted = encrypt(plainText, pubkey2); // 加密
const decrypted = decrypt(crypted, prikey2); // 解密
console.log("RSA非对称解密结果:%s", decrypted.toString());
```

### 内容签名类（RSA+SHA1 或 RSA+SHA256 或 RSA+MD5 等等）

“信息内容签名”其实和我们日常中对纸质文件进行签名是一个道理。又称为“数字签名”，包括报文摘要。报文摘要和非对称加密一起，提供数字签名的方法。

数字签名主要是**保证信息的完整和提供信息发送者的身份认证和不可抵赖性**，这其中，“完整性”主要就是由报文摘要提供的，报文摘要就是用来防止发送的报文被篡改。

**使用流程：**

- 使用 RSA 私钥进行签名（对信息报文生成的摘要进行私钥签名）生成签名串，一般是 16 进制字符串
- 使用 RSA 公钥进行签名校验（验明正身）

JWT 中的第三段签名就是内容签名的概念，将令牌头和参数信息进行摘要后生成一个全新的签名。

实际案例可以学习 [[HTTPS]]
