---
tags:
title: 前端性能优化
date created: 2023-04-04
date modified: 2023-06-19
---

# 前端性能优化

# 指标采集

- [[FCP]]
- [[TTI]]
- Page Load，页面完全加载时间。通常通过记录 window.performance.timing 中的 loadEventStart 与 fetchStart 的时间差来完成。
- [[FPS]]，前端页面帧率。通常是在主线程打点完成记录。其原理是 requestAnimationFrame 会在页面重绘前被调用，而 FPS 就是计算两次之间的时间差。
- 静态资源及 API 请求成功率。通常是通过 window. Performance. GetEntries ( ) 来获取相关信息
- 在性能监控中有一个概念叫 TP（Top Percentile），比如 TP50、TP90、TP99 和 TP999 等指标，指高于 50%、90%、99% 等百分线的情况。

# 时间角度优化：减少耗时

浏览器页面加载过程中，可以分为以下阶段：

1. 网络请求，服务端返回 HTML 内容；
2. 浏览器一边解析 HTML，一边进行页面渲染；
3. 解析到外部资源，会发起 HTTP 请求获取，加载 Javascript 代码时会暂停页面渲染；
4. 根据业务代码加载过程，会分别进入页面开始渲染、渲染完成、用户可交互等阶段；
5. 页面交互过程中，会根据业务逻辑进行逻辑运算、页面更新。

## **网络请求优化。**

网络请求优化的目标在于**减少网络资源的请求和加载耗时**，可以参考以下优化方案

- **减少 [[DNS]] 查询时间**，比如使用浏览器 DNS 缓存、计算机 DNS 缓存、服务器 DNS 缓存
- 合理地使用 [[CDN]]，有效地减少网络请求耗时；
- **对请求资源进行缓存**，包括但不限于使用浏览器缓存、HTTP 缓存、后台缓存，比如使用 Service Worker、PWA 等技术
- **移除代码中无用的部分**，比如使用 Tree-shaking、代码分割、移除用不上的依赖项等；
- **对请求资源进行合理的拆分**（CSS、Javascript 脚本、图片/音频/视频等），减少请求资源的体积；
- **对资源进行压缩，减少传输数据大小**；
- 使用 [[HTTP 2]]、[[HTTP 3]]，提升资源请求速度；
- **对请求进行优化**，比如对多个请求进行合并，减少通信次数；对请求进行域名拆分，提升并发请求数量。

## **首屏加载优化。**

其中，性能和渲染耗时优化属于技术优化手段，可以通过以下方式进行：

- 对页面进行分片/分屏加载，将页面可见/可交互时间提前；
- 优化资源加载的顺序和粒度，仅加载需要的资源，通过异步加载方式加载剩余资源；
- 使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块；
- 使用服务端直出渲染，减少页面二次请求和渲染的耗时；
- 使用秒看技术，通过预览的方式（比如图片）提前将页面内容提供给用户；
- 配合客户端进行资源预请求和预加载，比如使用预热 Web 容器；
- 配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染。

## **渲染过程优化。**

渲染过程的优化，主要在于减少用户的操作等待时间，避免出现卡顿的情况，比如：

- 使用资源预加载，在空闲时间，提前将用户可能需要用到的资源进行获取并加载；
- 减少 DOM 数量、减少/合并 DOM 操作，减少浏览器渲染过程中的计算耗时；
- 通过合理使用浏览器 GPU 合成，提升浏览器渲染效率；
- 使用离屏渲染，在页面不可见的地方提前进行渲染（比如 Canvas 渲染）；
- 通过将页面渲染帧率保持在 60FPS 左右，提升页面交互和渲染的流畅度。

## **计算/逻辑运行提速。**

计算/逻辑运行速度优化的方式主要包括：

- 通过将 Javscript 大任务进行拆解 + 并行计算的方式，有效地降低整体计算耗时，比如使用 [[Web Worker]]；
- 通过使用运行效率更高的方式，减少计算耗时，比如使用 [[Webassembly]]；
- 通过将计算过程提前，减少计算等待时长，比如使用 AOT 技术；
- 通过使用更优的算法或是存储结构，提升计算效率，比如 VSCode 使用红黑树优化文本缓冲区的计算；
- 通过将计算结果缓存的方式，减少运算次数。

# 空间角度优化：降低资源占用

资源占用常见的优化方式包括：

1. 合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、IndexDB），及时进行缓存清理；
2. 通过使用数据结构享元的方式，减少对象的创建，从而减少内存占用；
3. 避免存在内存泄漏，比如尽量避免全局变量的使用、及时解除引用等；
4. 避免复杂/异常的递归调用，导致调用栈的溢出。
